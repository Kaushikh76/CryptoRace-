{"ast":null,"code":"const STORAGE_KEY = 'crypto_price_predictor_rooms';\nconst getRooms = () => {\n  const rooms = localStorage.getItem(STORAGE_KEY);\n  return rooms ? JSON.parse(rooms) : {};\n};\nconst saveRooms = rooms => {\n  localStorage.setItem(STORAGE_KEY, JSON.stringify(rooms));\n};\nexport const createRoom = (roomCode, playerName, selectedCrypto) => {\n  const rooms = getRooms();\n  rooms[roomCode] = {\n    players: [{\n      name: playerName,\n      prediction: null,\n      amount: null\n    }],\n    started: false,\n    selectedCrypto: selectedCrypto,\n    startTime: null,\n    startPrice: null,\n    endTime: null,\n    endPrice: null,\n    winner: null\n  };\n  saveRooms(rooms);\n};\nexport const joinRoom = (roomCode, playerName) => {\n  const rooms = getRooms();\n  if (rooms[roomCode] && !rooms[roomCode].started) {\n    rooms[roomCode].players.push({\n      name: playerName,\n      prediction: null,\n      amount: null\n    });\n    saveRooms(rooms);\n    return true;\n  }\n  return false;\n};\n\n// Add this new function to get all players in a room\nexport const getRoomPlayers = roomCode => {\n  const rooms = getRooms();\n  return rooms[roomCode] ? rooms[roomCode].players : [];\n};\nexport const getRoomData = roomCode => {\n  const rooms = getRooms();\n  return rooms[roomCode] || null;\n};\nexport const updatePlayerPrediction = (roomCode, playerName, prediction, amount) => {\n  const rooms = getRooms();\n  if (rooms[roomCode]) {\n    const playerIndex = rooms[roomCode].players.findIndex(p => p.name === playerName);\n    if (playerIndex !== -1) {\n      rooms[roomCode].players[playerIndex].prediction = prediction;\n      rooms[roomCode].players[playerIndex].amount = amount;\n      saveRooms(rooms);\n    }\n  }\n};\nexport const startGame = (roomCode, startTimestamp, startPrice) => {\n  const rooms = getRooms();\n  if (rooms[roomCode]) {\n    rooms[roomCode].started = true;\n    rooms[roomCode].startTime = startTimestamp;\n    rooms[roomCode].startPrice = startPrice;\n    saveRooms(rooms);\n  }\n};\nexport const endGame = (roomCode, endTimestamp, endPrice) => {\n  const rooms = getRooms();\n  if (rooms[roomCode]) {\n    rooms[roomCode].endTime = endTimestamp;\n    rooms[roomCode].endPrice = endPrice;\n\n    // Determine the winner\n    const winner = rooms[roomCode].players.reduce((closest, player) => {\n      if (!player.prediction) return closest;\n      const currentDiff = Math.abs(player.prediction - endPrice);\n      const closestDiff = closest ? Math.abs(closest.prediction - endPrice) : Infinity;\n      return currentDiff < closestDiff ? player : closest;\n    }, null);\n    rooms[roomCode].winner = winner;\n    saveRooms(rooms);\n  }\n};\nexport const getSelectedCrypto = roomCode => {\n  const rooms = getRooms();\n  return rooms[roomCode] ? rooms[roomCode].selectedCrypto : null;\n};\nexport const fetchCryptocurrencies = async () => {\n  try {\n    const response = await fetch('https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=100&page=1&sparkline=false');\n    const data = await response.json();\n    return data.map(crypto => ({\n      id: crypto.id,\n      name: crypto.name,\n      symbol: crypto.symbol,\n      image: crypto.image\n    }));\n  } catch (error) {\n    console.error('Error fetching cryptocurrencies:', error);\n    return [];\n  }\n};\nexport const fetchHistoricalPrice = async (cryptoId, timestamp) => {\n  try {\n    const date = new Date(timestamp);\n    const formattedDate = `${date.getDate()}-${date.getMonth() + 1}-${date.getFullYear()}`;\n    const response = await fetch(`https://api.coingecko.com/api/v3/coins/${cryptoId}/history?date=${formattedDate}`);\n    const data = await response.json();\n    return data.market_data.current_price.usd;\n  } catch (error) {\n    console.error('Error fetching historical price:', error);\n    return null;\n  }\n};\nexport const clearRoom = roomCode => {\n  const rooms = getRooms();\n  if (rooms[roomCode]) {\n    delete rooms[roomCode];\n    saveRooms(rooms);\n  }\n};","map":{"version":3,"names":["STORAGE_KEY","getRooms","rooms","localStorage","getItem","JSON","parse","saveRooms","setItem","stringify","createRoom","roomCode","playerName","selectedCrypto","players","name","prediction","amount","started","startTime","startPrice","endTime","endPrice","winner","joinRoom","push","getRoomPlayers","getRoomData","updatePlayerPrediction","playerIndex","findIndex","p","startGame","startTimestamp","endGame","endTimestamp","reduce","closest","player","currentDiff","Math","abs","closestDiff","Infinity","getSelectedCrypto","fetchCryptocurrencies","response","fetch","data","json","map","crypto","id","symbol","image","error","console","fetchHistoricalPrice","cryptoId","timestamp","date","Date","formattedDate","getDate","getMonth","getFullYear","market_data","current_price","usd","clearRoom"],"sources":["F:/crypto-chicken-run/src/services/roomService.js"],"sourcesContent":["const STORAGE_KEY = 'crypto_price_predictor_rooms';\r\n\r\nconst getRooms = () => {\r\n  const rooms = localStorage.getItem(STORAGE_KEY);\r\n  return rooms ? JSON.parse(rooms) : {};\r\n};\r\n\r\nconst saveRooms = (rooms) => {\r\n  localStorage.setItem(STORAGE_KEY, JSON.stringify(rooms));\r\n};\r\n\r\nexport const createRoom = (roomCode, playerName, selectedCrypto) => {\r\n  const rooms = getRooms();\r\n  rooms[roomCode] = { \r\n    players: [{ name: playerName, prediction: null, amount: null }], \r\n    started: false,\r\n    selectedCrypto: selectedCrypto,\r\n    startTime: null,\r\n    startPrice: null,\r\n    endTime: null,\r\n    endPrice: null,\r\n    winner: null\r\n  };\r\n  saveRooms(rooms);\r\n};\r\n\r\nexport const joinRoom = (roomCode, playerName) => {\r\n  const rooms = getRooms();\r\n  if (rooms[roomCode] && !rooms[roomCode].started) {\r\n    rooms[roomCode].players.push({ name: playerName, prediction: null, amount: null });\r\n    saveRooms(rooms);\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n\r\n// Add this new function to get all players in a room\r\nexport const getRoomPlayers = (roomCode) => {\r\n  const rooms = getRooms();\r\n  return rooms[roomCode] ? rooms[roomCode].players : [];\r\n};\r\n\r\n\r\nexport const getRoomData = (roomCode) => {\r\n  const rooms = getRooms();\r\n  return rooms[roomCode] || null;\r\n};\r\n\r\nexport const updatePlayerPrediction = (roomCode, playerName, prediction, amount) => {\r\n  const rooms = getRooms();\r\n  if (rooms[roomCode]) {\r\n    const playerIndex = rooms[roomCode].players.findIndex(p => p.name === playerName);\r\n    if (playerIndex !== -1) {\r\n      rooms[roomCode].players[playerIndex].prediction = prediction;\r\n      rooms[roomCode].players[playerIndex].amount = amount;\r\n      saveRooms(rooms);\r\n    }\r\n  }\r\n};\r\n\r\nexport const startGame = (roomCode, startTimestamp, startPrice) => {\r\n  const rooms = getRooms();\r\n  if (rooms[roomCode]) {\r\n    rooms[roomCode].started = true;\r\n    rooms[roomCode].startTime = startTimestamp;\r\n    rooms[roomCode].startPrice = startPrice;\r\n    saveRooms(rooms);\r\n  }\r\n};\r\n\r\nexport const endGame = (roomCode, endTimestamp, endPrice) => {\r\n  const rooms = getRooms();\r\n  if (rooms[roomCode]) {\r\n    rooms[roomCode].endTime = endTimestamp;\r\n    rooms[roomCode].endPrice = endPrice;\r\n\r\n    // Determine the winner\r\n    const winner = rooms[roomCode].players.reduce((closest, player) => {\r\n      if (!player.prediction) return closest;\r\n      const currentDiff = Math.abs(player.prediction - endPrice);\r\n      const closestDiff = closest ? Math.abs(closest.prediction - endPrice) : Infinity;\r\n      return currentDiff < closestDiff ? player : closest;\r\n    }, null);\r\n\r\n    rooms[roomCode].winner = winner;\r\n    saveRooms(rooms);\r\n  }\r\n};\r\n\r\nexport const getSelectedCrypto = (roomCode) => {\r\n  const rooms = getRooms();\r\n  return rooms[roomCode] ? rooms[roomCode].selectedCrypto : null;\r\n};\r\n\r\nexport const fetchCryptocurrencies = async () => {\r\n  try {\r\n    const response = await fetch('https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=100&page=1&sparkline=false');\r\n    const data = await response.json();\r\n    return data.map(crypto => ({\r\n      id: crypto.id,\r\n      name: crypto.name,\r\n      symbol: crypto.symbol,\r\n      image: crypto.image,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching cryptocurrencies:', error);\r\n    return [];\r\n  }\r\n};\r\n\r\nexport const fetchHistoricalPrice = async (cryptoId, timestamp) => {\r\n  try {\r\n    const date = new Date(timestamp);\r\n    const formattedDate = `${date.getDate()}-${date.getMonth() + 1}-${date.getFullYear()}`;\r\n    const response = await fetch(`https://api.coingecko.com/api/v3/coins/${cryptoId}/history?date=${formattedDate}`);\r\n    const data = await response.json();\r\n    return data.market_data.current_price.usd;\r\n  } catch (error) {\r\n    console.error('Error fetching historical price:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\nexport const clearRoom = (roomCode) => {\r\n  const rooms = getRooms();\r\n  if (rooms[roomCode]) {\r\n    delete rooms[roomCode];\r\n    saveRooms(rooms);\r\n  }\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}